import { Injectable } from '@angular/core';
import { Http } from '@angular/http';
import { RemoteService } from './remote-service';
import { SqlService } from './sql-service';
import { Observable } from 'rxjs/Observable';
import { Observer } from 'rxjs/Observer';
import * as Rx from 'rxjs/Rx'; 
import { ResourceCollection, BaseResource, Unit, Property, Global, Formula, Variable, FormulaGlobal, Category, States, OpCodes, ItemSyncState, OfflineData} from '../types/standard';
import { UIStateService } from './ui-state-service'
import { Platform } from 'ionic-angular';
/*
 * 
 *
 *
*/
@Injectable()
export class DataService {

    // categories: ResourceCollection;
    properties: ResourceCollection<Property> = new ResourceCollection<Property>(this, Property);
    globals: ResourceCollection<Global> = new ResourceCollection<Global>(this, Global);
    units: ResourceCollection<Unit> = new ResourceCollection<Unit>(this, Unit);
    formulas: ResourceCollection<Formula> = new ResourceCollection<Formula>(this, Formula);
    variables: ResourceCollection<Variable> = new ResourceCollection<Variable>(this, Variable);;
    formulas_globals: ResourceCollection<FormulaGlobal> = new ResourceCollection<FormulaGlobal>(this, FormulaGlobal);
    categories: ResourceCollection<Category> = new ResourceCollection<Category>(this, Category);


    // formulas: ResourceCollection;
    resourceTables: Array<string> = ['properties', 'units', 'globals'
        , 'formula', 'variables', 'formulas_globals'
        , 'categories'];

    currentSync: Date;
    initComplete: boolean = false;
    constructor(private platform: Platform
        , public remoteService: RemoteService
        , public sqlService: SqlService
        , private uiService: UIStateService) {
        this.init().subscribe(res => {
                this.handleSqlResult(res);
            },err => {
                this.handleSqlError(err);
            },()=>{
                console.log('Info:Dataservice init complete')
            })
    }

    init():Observable<any> {
        var dropdb = localStorage.getItem("dropdb");
        localStorage.setItem("dropdb", "0");
        if(dropdb)
          dropdb = parseInt(dropdb);
        else
          dropdb = 0;
        if(this.initComplete)
            return Observable.create(or => or.complete())
        else 
            return this.sqlService.init(dropdb);
    }

    setKV(key:string, value:Object):Observable<any>{
        return this.sqlService.setKV(key, JSON.stringify(value))
    }

    getKV(key):Observable<any>{
        return this.sqlService.getKV(key);
    }

    
    loadListAndDepenent(list:ResourceCollection<BaseResource>):Observable<any>{
        var lists = this.getDepentent(list);
        return Observable.from(lists)
                  .flatMap(li => [this.load(li) , this.loadDeletedItems(li), this.loadLastSync(li)])
                  .concat([this.sync(list)])
                  .concatAll()
    }
    
    load(li:ResourceCollection<BaseResource>):Observable<any>{
      return Observable.create(or => {
          this.sqlService.query('select', this.getTable(li), null, null)
              .subscribe(res => {
                  this.handleSqlResult(res);
                  this.addRows(li, res.res.rows)
              },err => {
                  this.handleSqlError(err);
                  or.error(err);
              },()=>{
                  or.complete();
              })
      })        
    }

    loadDeletedItems(li: ResourceCollection<BaseResource>):Observable<any> {
        var table = this.getTable(li);
        return Observable.create(or => {
            this.getKV('deletedItems_'+table)
                .subscribe(res => {
                    this.handleSqlResult(res);
                    if(res)
                      li.offlineData.deletedItems = JSON.parse(res);
                    else
                      li.offlineData.deletedItems = new Array<any>();
                }, err => {
                    this.handleSqlResult(err);
                    or.error(err)
                },
                () => {
                  console.log('Info: loadDeleteItems completed')
                  or.complete()
                })
        })
    }

    loadLastSync(li:ResourceCollection<BaseResource>):Observable<any>{
      return Observable.create(or => {
        this.getKV('lastSync_'+this.getTable(li)).subscribe(res =>{
          this.handleSqlResult(res);
          li.offlineData.lastSync = res;
        }, err=>{
          this.handleSqlError(err);
          or.err(err);
        },()=>{
          console.log('Info: loadLastSync completed')
          or.complete();
        })
      })
    }


    sync(li):Observable<any> {
      var lists = this.getDepentent(li);
      return Observable.create(or => {
          var offLineData = new OfflineData(lists);
          //Handle response for sync opertaion
          this.remoteService
              .sync({syncInfo: offLineData.asJson()})
              .subscribe(od => {
                this.handleSyncResponse(od)
                    .subscribe(res => {
                      this.handleSqlResult(res);
                    },err=>{
                      this.handleSqlError(err);
                      or.error(err);
                    },()=>{
                      console.log('Info: handleSyncResponse completed')
                      or.complete();
                    })
            })
      })
    }

    handleSqlResult(res){
      if(!res || !res.res)
        return;
      res = res.res;
      if(res.stmt)
        console.log(res.stmt);
      if(res.rowsAffected)
        console.log("No of rows affected - " + res.rowsAffected);
    }

    handleSqlError(err){
      if(!err || !err.err)
        return;
      err = err.err;
      if(err.stmt)
        console.log(err.stmt)
      if(err.code)
        console.log('Error code - ' +  err.code)
      if(err.message)
        console.log('Error message - ' +  err.message)
    } 

    handleSyncResponse(res:OfflineData): Observable<any>{
        res.tables.forEach(t => {
            var li =  this[t.name] as ResourceCollection<BaseResource>;
            li.offlineData.lastSync = t.lastSync;
            
            //Clear table deleted items
            li.offlineData.deletedItems = [];

            //set remote bit for offline data
            li.offlineData.clearSyncState()

            //New items
            var jsonResources = t.resources;
            console.log('The no of record for table - ' + this.getTable(li) + ' - ' + jsonResources.length)
            t.resources = new Array<BaseResource>();
            jsonResources.forEach(i => {
                if(i.oldId){
                   var lobj  = li.getItem("id", i.oldId)
                   lobj.oldId = i.oldId;
                   this.updateIdsForAllLists(li, i.oldId, i.id);
                   t.resources.push(lobj);
                }
            })
            //Remove json item from list
            jsonResources = jsonResources.filter(i => i.oldId == null)
            jsonResources.forEach(i => {
               var obj = new li.type(i) as BaseResource;
               var lobj = li.getItem("id", obj.id)
               if(i.deleted){
                   if(lobj)
                     li.remove(obj, false, true);
               }
               else if(lobj == null)
                 li.add(obj, true);
               else
                  lobj.loadState(i)
               
               t.resources.push(obj);
            })
        })

        // res.tables.forEach(t => {
        //   var li = this[t.name]
        //   t.resources.forEach(r => {
        //     r.init(this.getInitParameters(li))
        //   })
        // })

        return Observable.from(res.tables)
                         .map(t => [this.setKV('deletedItems_'+ t.name, this[t.name].offlineData.deletedItems)
                           , this.lupdateIdsSync(t.resources)
                           , this.lsaveResourcesSync(t.resources)
                           , this.setKV('lastSync_'+t.name, t.lastSync)
                           , this.lclearSyncState(t.name)
                           ])
                         .flatMap(i => i)
                         .concatAll()
    }
    
    //Update forign key ids of particular table
    lclearSyncState(table):Observable<any>{
        var obj = {};
        obj['syncState'] = 0;
        return this.sqlService.query("update", table, obj, null)
    }


    lupdateIdsSync(resources):Observable<any>{
        return Observable.interval(200)
                  .take(resources.length)
                  .flatMap(i =>  this.lupdateIdItemSync(resources[i]))
                  .concatAll()
    }

    lsaveResourcesSync(resources):Observable<any>{
        return Observable.interval(200)
                  .take(resources.length)
                  .flatMap(i =>  this.lsaveItemSync(resources[i]))
                  .concatAll()
    }


    lupdateIdItemSync(i:BaseResource):Observable<any>[]{
        var li = this[i.getTable()] as ResourceCollection<BaseResource>;
        if(i.oldId)
            return this.lupdateIdsForAllLists(li, i.oldId, i.id) 
        else
            return [Observable.empty()]

    }

    lsaveItemSync(i:BaseResource):Observable<any>[]{
        var li = this[i.getTable()] as ResourceCollection<BaseResource>;
        if(i.oldId)
            return [Observable.empty()]
        else if(i.deleted)
            return [this.ldelete(i)]
        else
            return [this.laddorupdate(i)]
    }


    lupdateIdsForAllLists(list, oldId, newId):Observable<any>[] {
        switch (list) {
            case this.properties:
                return [this.lupdateIds(this.getTable(this.properties), 'id', oldId, newId)
                        ,this.lupdateIds(this.getTable(this.units), 'property_id', oldId, newId)];
            case this.units:
                return [this.lupdateIds(this.getTable(this.units), 'id', oldId, newId)];
            default:
                return [];
        }
    }     


    ldeleteIdsForAllLists(r:BaseResource):Observable<any> {
        switch (this[r.getTable()]) {
            case this.properties:
                return this.ldeleteIds(this.getTable(this.units), 'property_id', r.id);
            case this.units:
                return Observable.empty();
            default:
                return Observable.empty();
        }
    }

    //Update forign key ids of particular table
    lupdateIds(table, col, oldId, newId):Observable<any>{
        var cond = { and: {  } } ;
        cond.and[col] = {cond: '=', value:oldId}
        var obj = {};
        obj[col] = newId;
        return this.sqlService.query("update", table, obj, cond)
    }

    //Update forign key ids of particular table
    ldeleteIds(table, col, id):Observable<any>{
        var cond = { and: {  } } ;
        cond.and[col] = {cond: '=', value:id}
        return this.sqlService.query("delete", table, null, cond)
    }


    radd(r:BaseResource):Observable<any>{
        return Observable.create(or => {
             this.remoteService
               .add(r.getTable(), r.getState())
               .subscribe(res => {
                   r.id = res.id;
                   r.clearSyncState(ItemSyncState.NEW)
               }, err=> {
                   console.log('Error: radd - ' + err);
               }, ()=> {
                   console.log('Success:radd');
                   or.complete();
               })
           })
    }

    ladd(r:BaseResource):Observable<any>{
        return Observable.create(or => {
            this.sqlService
                .query("insert", r.getTable(), r.getState(), null)
                .subscribe(res => {
                    if(res.res.insertId){
                        r.id = res.res.insertId;
                    }
                }, err=> {
                    console.log('Error: ladd - ' + err);
                }, ()=> {
                    console.log('Success: ladd');
                    or.complete();
                })
            })
    }
    
    //used when sync from remote
    laddorupdate(r:BaseResource):Observable<any>{
        return Observable.create(or => {
            this.sqlService
                .query("insertorupdate", r.getTable(), r.getState(), null)
                .subscribe(res => {
                    this.handleSqlResult(res);
                }, err=> {
                   this.handleSqlError(err);
                }, ()=> {
                    or.complete();
                })
            })
    }


    rupdate(r: any):Observable<any> {
      return Observable.create(or => {
          this.remoteService
              .update(r.getTable(), r.getState())
              .subscribe(res => {
                  r.clearSyncState(ItemSyncState.CHANGE);
              }, err=> {
                  console.log('Error: rupdate - ' + err);
              }, ()=> {
                  console.log('Success: rupdate');
                  or.complete();
              })
          })
    }


    lupdate(r: BaseResource) :Observable<any>{
      return Observable.create(or => {
          var cond = { and: { id: { cond: '=', value: r.id } } };
          this.sqlService
              .query("update", r.getTable(), r.getState(), cond)
              .subscribe(res => {
              }, err=> {
                  console.log('Error: lupdate - ' + err);
              }, ()=> {
                  console.log('Success: lupdate');
                  or.complete();
              })
          })

    }

    rdelete(r: any) :Observable<any>{
        return Observable.create(or => {
          this.remoteService
               .delete(r.getTable(), r.getState())
               .subscribe(res => {
                    r.clearSyncState(ItemSyncState.DELETE);
                }, err=> {
                    console.log('Error rdelete' + err);
                }, ()=> {
                    console.log('rdelete success');
                    or.complete();
                })
            })
    }

    ldeleteMany(table, ids):Observable<any>{
      return Observable.create(or => {
        var cond = { and: { id: { cond: 'in', value: ids } } };
        this.sqlService
            .query("delete", table, null, cond)
            .subscribe(res => {
                }, err=> {
                    console.log('Error ldeleteMany' + err);
                }, ()=> {
                    console.log('ldeleteMany success');
                    or.complete();
                })
            })
    }

    ldelete(r:any):Observable<any>{
        return Observable.create(or => {
          var cond = { and: { id: { cond: '=', value: r.id } } };
          this.sqlService
              .query("delete", r.getTable(), r.getState(), cond)
              .subscribe(res => {
                  }, err=> {
                      console.log('Error ldelete' + err);
                  }, ()=> {
                      console.log('ldelete success');
                      or.complete();
                  })
              })
    }

    
    add(r: BaseResource) :Observable<any>{
      r.setSyncState(ItemSyncState.NEW);
       var add = Observable.create(or => {
           this[r.getTable()].add(r);
           or.complete();
       })
       return Observable.from([this.radd(r), this.ladd(r), add])
                 .concatAll()
    }


    update(r:BaseResource):Observable<any>{
        r.setSyncState(ItemSyncState.CHANGE);
        this[r.getTable()].onUpdate(r);
        return Observable.from([this.rupdate(r), this.lupdate(r)])
                  .concatAll()
    }

    remove(r:BaseResource):Observable<any>{
        r.setSyncState(ItemSyncState.DELETE);
        var remove = Observable.create(or => {
           var li = this[r.getTable()] as ResourceCollection<BaseResource>;
           this[r.getTable()].remove(r);
           this.deleteChildren(r)
           if(r.isDeletePending()){
                 this.setKV('deletedItems_' + r.getTable(), li.offlineData.deletedItems)
                 .subscribe(r => {
                     console.log('saveDeletedItems success');
                     or.complete();
                 },err => {
                   console.log('saveDeletedItems error ' + err);
                   or.error(err);
                 },()=>{
                   console.log('saveDeletedItems complete');
                   or.complete();
                 })
           }
           else
             or.complete()
        })
        return Observable.from([this.rdelete(r), this.ldelete(r), this.ldeleteIdsForAllLists(r), remove])
                    .concatAll()
    }

    saveItem(r:BaseResource):Observable<any>{
       if(r.id == null){
           return this.add(r)
       }
       else
           return this.update(r)
    }

    saveItemRecursive(r:BaseResource):Observable<any>{
       var items = [r];
       items = items.concat(r.getUnsavedChildItems());
       return Observable.from(items)
                 .map(r => this.saveItem(r))
                 .concatAll()
    }

    initListItem(list){
      list.initItems(this.getInitParameters(list))
    }

    getInitParameters(list):any{
        switch (list) {
             case this.properties:
                return { ulist: this.units };
             case this.units:
                 return { plist: this.properties};
             default :
                 return {};
        }   
    }

    deleteChildren(r:BaseResource){
        var list = this[r.getTable()]
         switch (list) {
             case this.properties:
                 r.Units.forEach(u => this.units.remove(u, true));
                 this.formulas.filter(f => f.property_id == r.id).forEach(f => this.formulas.remove(f, true))
                 break;
              case this.units:
                  this.formulas.filter(f => f.unit_id == r.id).forEach(f => this.formulas.remove(f, true))
                  break;
              default :
                  return;
         }   
    }

    updateIdsForAllLists(list, oldId, newId) {
        switch (list) {
            case this.properties:
                this.changeItemId(list, "id", oldId, newId);
                this.changeItemId(this.units, "property_id", oldId, newId);
                break;
            case this.units:
                this.changeItemId(list, "id", oldId, newId);
                break;
            default:
                return;
        }
    }


    changeItemId(li:ResourceCollection<BaseResource>,col:string, oldId: number, newId: number){
        var item = li.getItem(col, oldId);
        item[col] = newId;
    }

    getTable(list: ResourceCollection<BaseResource>): string {
        return list.type.table;
    }

    isDepententInSync(list: ResourceCollection<BaseResource>){
        var deps = this.getDepentent(list);
        return deps.filter(a => a.offlineData.lastSync != list.offlineData.lastSync).length == 0
    }

    getDepentent(list):ResourceCollection<BaseResource>[]{
        switch (list) {
            case this.properties:
                return [this.properties, this.units];
            default:
                return [];
        }
    }

    addRows(li:ResourceCollection<BaseResource>, rows){
       var i;
       for(i=0; i< rows.length; i++){
         var obj = new li.type(rows.item(i))
         li.add(obj)
       }
    }    

}

//=============
//standard.js
//=============
import { Observable } from 'rxjs/Observable';
import { Observer } from 'rxjs/Observer';
import { DataService } from '../services/data-service';
import { SqlService } from '../services/sql-service';
import { RemoteService } from '../services/remote-service';

export class ResourceCollection<T extends BaseResource>{
    //Data stream
    resources: Array<T>;
    ole: Observable<any>;
    or: Observer<any>;
    
    //State stream
    state: number;
    sole: Observable<any>;
    sor: Observer<any>;

    offlineData: TableOfflineData;

    constructor(public controller: DataService
        , public type: any)
    {

        this.resources = new Array<T>();
        this.state = States.CREATED;

        this.ole = new Observable(or => {
            this.or = or;
            this.controller.loadListAndDepenent(this)
                .subscribe(null,null,() => {
                    this.controller.initListItem(this);
                    or.next(this.resources)
                })
        });

        this.offlineData = new TableOfflineData(type.table);
    }

    initItems(info) {
        this.resources.forEach(r => { r.init(info) })
    }

    getItem(key: string, val: any): T {
        return this.resources.find(r => r[key] == val)
    }

       
    add(r:T, syncronizing:boolean =false){
        this.resources.push(r);
        if(!syncronizing)
            this.offlineData.addResource(r);
    }

    onUpdate(r:T){
        this.offlineData.addResource(r);
    }


    remove(r1:T, child:boolean = false, syncronizing:boolean =false){
        var r = this.getItem("id", r1.id)
        if(r){
            this.resources.splice(this.resources.indexOf(r))
            if(!child && !syncronizing)
                this.offlineData.addResource(r1)
            if(this.or)
                this.or.next(this.resources);
        }
    }

    
    set State(state){
        this.state = state;
        console.log('Set state - ' + state)
    }

    get State(){
        console.log('Get state - ' + this.state)
        return this.state;
    }

    map(callbackfn: (value: T, index: number, array: T[]) => any, thisArg?: any) {
        return this.resources.map(callbackfn, thisArg);
    }

    filter(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any) {
        return this.resources.filter(callbackfn, thisArg);
    }

    find(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any) {
        return this.resources.find(predicate, thisArg)
    }

    get length():number{
        return this.resources.length;
    }
}

export class BaseResource {
    id: number;
    name: string;


    //Internal
    oldId: number;
    deleted:string;
    syncState: number = 0;
    oldState:any;
    constructor(state){
        this.loadState(state);
    }

    init(obj:any =null) {

    }

    loadState(state){
        this.id = state.id;
        this.name = state.name;
        this.syncState = state.syncState;
        this.deleted = state.deleted;
        if(this.syncState == null)
            this.syncState = 0;
    }

    getState(){
        return { id: this.id, name: this.name, syncState: this.syncState };
    }


    getTable(){
        return "";
    }

    
    setSyncState(state){
        this.syncState |= state;
    }

    clearSyncState(state){
        this.syncState &= ~state;
    }

    clearAllSyncState(){
        this.syncState = 0;
    }
  
    initMeasure(info:any, property_id:number, unit_id:number):Measure{
        var ulist = info.ulist as Array<Unit>;
        var plist = info.plist as Array<Property>;
        if(property_id){
            plist.forEach(p => {
                if (p.id == property_id)
                    return new Measure(p);
            })
        }
        if(unit_id){
            ulist.forEach(u => {
                if(u.id == unit_id){
                    return  new Measure(u);
                }
            })
        }
        return null;
    }

    destroy(){

    }

    getUnsavedChildItems(){
        return [];
    }

    enterEdit(){
        this.oldState = this.getState();
        this.setSyncState(ItemSyncState.CHANGE);
    }
    
    isNewPending():boolean{
       return (ItemSyncState.NEW & this.syncState) != 0
    }

    isUpdatePending():boolean{
        return (ItemSyncState.CHANGE & this.syncState) != 0
    }

    isDeletePending():boolean{
        return (ItemSyncState.DELETE & this.syncState) != 0
    }

}
    
export class Unit extends BaseResource {
    static table: string = 'units';
    
    system: string;
    baseunit: boolean;
    symbol: string;
    prefix: any;
    extend: any;
    definition: string;
    description: string;
    approx: boolean;
    factor: string;
    repeat: any;
    property_id: number;
    

    //local members
    _property: Property;
    _latex: string;

    constructor(state: any = {}) {
        super(state);
        if (!this.factor)
            this.factor = "5";
        if (!this.name)
            this.name = "New Unit"
        if (!this.symbol)
            this.symbol = "ss"
        if(!this.system)
            this.system = "SI"
    }

    init(info){
        if(info.property){
            this._property = info.property;
        }
        else{
            if(info.plist && !this._property){
                var p = info.plist.getItem("id", this.property_id)
                if(p.units.indexOf(this) == -1)
                    p.units.push(this)
                this._property = p;
            }

        }
        this._latex = this.parseLatex(this.symbol); 
    }
    
    getState(){
        return Object.assign(super.getState(), { 
          system: this.system,
          baseunit: this.baseunit,
          symbol: this.symbol,
          prefix: this.prefix,
          extend: this.extend,
          definition: this.definition,
          description: this.description,
          approx: this.approx,
          factor: this.factor,
          repeat: this.repeat,
          property_id: this.Property? this.Property.id: this.property_id
        });
    }

    loadState(state){
        super.loadState(state);
        this.system = state.system;
        this.baseunit = state.baseunit;
        this.symbol = state.symbol;
        this.prefix = state.prefix;
        this.extend = state.extend;
        this.definition = state.definition;
        this.description = state.description;
        this.approx = state.approx;
        this.factor = state.factor;
        this.repeat = state.repeat;
        this.property_id = state.property_id;
    }

    getTable():string{
        return Unit.table;
    }

    get Latex():string{
        return this._latex;
    }

    set Symbol(val:string){
        this.symbol = val;
         this._latex = this.parseLatex(this.symbol);   
    }

    get Symbol():string {
        return this.symbol;
    }

    parseLatex(symbol):string {
        var s1 = ''
        var s = symbol
        if(s){
            if(s.length == 1){
                if (s == '_')
                    return this._latex = "\\text{" + this.name + "}";
                return this._latex = "\\text{" + s +"}";
            }
            //replace H2o as H_2o
            s1 = s.replace('H2O', 'H_2O');
            //replace ([a-zA-A])([1-9]) with g1^g2
            var p=/([A-Za-z])([1-9])/
            var s2='';
            while (s1 != s2){
                s2 = s1;
                s1 = s1.replace(p, "$1^$2")
            }
            //replace ((a-zA-A )*) with \text{g1}
            var p2=/([A-Za-z /]+)/
            var s2=''
            var part1='';
            while (s1 != s2){
                s2 = s1;
                s1 = s1.replace(p2, "\\text{$1}")
                if(s1 != s2){
                    part1 += s1.slice(0,s1.lastIndexOf('}')+1)
                    s1 = s1.slice(s1.lastIndexOf('}')+1);
                }
                else{
                    part1 += s1;
                }
            }
            s1 = part1;
            return this._latex = s1;
        }
         return this._latex = s1
    }

    
    get IsDefaultUnit(){
        return this.Factor == 1;
    }

    get Property(){
        return this._property;
    }

    get Factor(){
        if (!this.factor || this.IsFormulaFactor)
            return null;
        else 
            return parseFloat(this.factor);
    }

    get FormulaFactor(){
        if (this.IsFormulaFactor) 
            return this.factor;
        else 
            return null;
    }

    get IsFormulaFactor(){
        if(!this.factor)
            return false;
        return this.factor.indexOf('x') != -1;
    }


    newFormula():Formula{
        var formula = new Formula()
        formula._measure = new Measure(this);
        return formula;
    }

    newGlobal():Global{
        var global = new Global()
        global._unit = this;
        return global;
    }
}

export class Property extends BaseResource {
    static table: string = 'properties';
    _defaultUnit: Unit;
    _units: Unit[] = new Array<Unit>();
    
    constructor(state: any = {}) {
        super(state);
        if(!this.name)
            this.name = "New Property"
    }

    //called first time after loading
    init(info:any){
        var ulist = info.ulist;
        ulist.resources.forEach(u => {
            if(u.property_id == this.id){
                u.init({property:this})
                this._units.push(u)
                if(u.Factor == 1)
                    this._defaultUnit = u 
            }
        })
    }

    getTable(){
        return Property.table;
    }
    
    get DefaultUnit(){
        return this._defaultUnit;
    }

    newUnit(isDefault: boolean = false):Unit{
        var unit = new Unit();
        unit.init({property:this});
        this._units.push(unit);
        if (isDefault){
             unit.factor = "1";
             this._defaultUnit = unit;
        }
        return unit;
    }

    get Units():any{
            return this._units;
    }

    newFormula():Formula{
        var formula = new Formula({property_id: this.id})
        return formula;
    }


    getUnsavedChildItems(){
        var arr=[];
        arr.push(this._defaultUnit);
        return arr;
    }
}


export class Global extends BaseResource {
    unit_id: number;
    value: string;
    symbol: string;
    static table:string = "globals";

    //private
    _unit: Unit;
    constructor(state:any = {}) {
        super(state);
        if (!this.name)
            this.name = "New Global";
    }

    init(info:any){
        var ulist = info.ulist;
        ulist.forEach(u => {
            if(u.id == this.unit_id){
                this._unit = u;
            }
        })
    }

    getTable(){
        return Global.table;
    }

    getState(){
        return Object.assign(super.getState(), { 
          unit_id: this._unit?this._unit.id: this.unit_id,
          value: this.value,
          symbol: this.symbol,
        });
    }

    loadState(state){
        super.loadState(state);
        this.unit_id = state.unit_id;
        this.value = state.value;
        this.symbol = state.symbol;
    }

    get Measure(){
        return this._unit;
    }
}

export class Measure {
    constructor(public measure:Property | Unit){

    }

    isProperty():boolean {
        return !this.measure.hasOwnProperty("property_id");
    }

    isUnit():boolean{
        return this.measure.hasOwnProperty("property_id");
    }
}

export class Formula extends BaseResource {
    symbol: string;
    latex: string;
    property_id: number;
    unit_id: number;
    static table: string = "formulas";

    //private
    _measure: Measure;

    constructor(state: any = {}) {
        super(state);
    }

    init(info:any){
        this._measure = this.initMeasure(info, this.property_id, this.unit_id);
    }

    getTable(){
        return Formula.table;
    }

    getState() {
        return Object.assign(
                super.getState(), { 
                symbol: this.symbol,
                latex: this.latex,
                property_id: this._measure ? (this._measure.measure.id ? null : this._measure.measure.id) : this.property_id,
                unit_id: this._measure ? (this._measure.measure.id ? this._measure.measure.id : null) : this.unit_id,
            });
    }

    loadState(state) {
        super.loadState(state);
        this.symbol = state.symbol;
        this.latex = state.latex;
        this.property_id = state.property_id;
        this.unit_id = state.unit_id;
    }

    get Measure(){
        return this._measure;
    }

}

export class Variable extends BaseResource {
    unit_id: number;
    property_id: number;
    formula_id: number;
    symbol: string;
    static table:"variables"
    
    //private
    _formula: Formula;
    _measure: Measure;
    constructor(state:any = {}) {
        super(state);
    }

    init(info){
        this._formula = info.formula;
        this._measure = this.initMeasure(info, this.property_id, this.unit_id);
    }

    getTable() {
        return Variable.table;
    }

    getState(){
        return Object.assign(super.getState(), { 
          property_id: this._measure ? (this._measure.measure.id ? null : this._measure.measure.id) : this.property_id,
          unit_id: this._measure ? (this._measure.measure.id ? this._measure.measure.id : null) : this.unit_id,
          symbol: this.symbol
        });
    }

    loadState(state){
        super.loadState(state);
        this.unit_id = state.unit_id;
        this.property_id = state.property_id;
        this.symbol = state.symbol;
    }

    get Formula(){
        return this._formula;
    }

    get Measure(){
        return this._measure;
    }
}




export class FormulaGlobal extends BaseResource {
    formula_id: number;
    global_id: number;
    static table:string = "formulas_globals"

    _formula: Formula;
    _global: Global;
    constructor(state:any) {
        super(state)
        this.loadState(state);
    }

    init(info){
        var flist = info.flist as Array<Formula>;
        var glist = info.glist as Array<Global>;
        flist.forEach(f => {
            if(f.id == this.formula_id){
                this._formula = f;
            }
        })
        glist.forEach(g => {
            if(g.id == this.global_id){
                this._global = g;
            }
        })
    }

    getTable() {
        return FormulaGlobal.table;
    }

    getState(){
       return Object.assign({}, 
        { 
            formula_id: this._formula?this._formula.id:this.formula_id,
            global_id: this._global?this._global.id:this.global_id
         });
    }

    loadState(state){
        this.formula_id = state.formula_id;
        this.global_id = state.global_id;
    }
}

export class Category extends BaseResource {
    parent_id: number;
    
    _parent: Category;
    children: Category[];
    
    static table: string = "categories";

    constructor(state:any) {
        super(state);
    }

    init(info){

    }

    getTable():string{
        return Category.table;
    }

    getState(){
        return Object.assign(super.getState(), { parent_id: this._parent?this._parent.id:this.parent_id });
    }

    loadState(state){
        super.loadState(state);
        this.parent_id = state.parent_id;
    }

    onListLoadComplete(){
        
    }
}

export class TableOfflineData {
    resources: Array<BaseResource> = new Array<BaseResource>();
    deletedItems: Array<any> = new Array();
    lastSync:string="";

    constructor(public name:string){
    }

    addResource(res:BaseResource){
        if(res.isDeletePending()){
            if(!res.isNewPending)
                this.deletedItems.push({id: res.id});
            else
                this.resources.splice(this.resources.indexOf(res));
        }
        else if((res.isNewPending() || res.isUpdatePending()) && this.resources.indexOf(res) == -1)
            this.resources.push(res);
    }

    clearSyncState(){
        this.resources.forEach(i => {
            i.syncState = 0;
        })
    }

    hasOfflineData():boolean{
        return (this.resources.length != 0 || this.deletedItems.length != 0)
    }

    asJSON(){
        return {resources: this.resources.map(r => r.getState())
                ,name: this.name
                ,deletedItems: this.deletedItems
                ,lastSync:this.lastSync}
    }
}

export class OfflineData {
    transactionId:string;
    clientId:string;
    tables:Array<TableOfflineData> = new Array<TableOfflineData>();

    constructor(lists:ResourceCollection<BaseResource>[]){
        this.init(lists);
    }

    init(lists:ResourceCollection<BaseResource>[]){
        this.transactionId = ""
        this.clientId = ""
        lists.forEach(li => {
            this.tables.push(li.offlineData);
        })
    }

    asJson(){
        var jsonData = {transactionId: this.transactionId, clientId: this.clientId, tables:[] }
        this.tables.forEach(t => jsonData.tables.push(t.asJSON()))
        return jsonData;
    }
}

export class States {
    static CREATED:number = 0
    static  LOAD_STARTED:number = 1;
    static  LOAD_COMPLETE:number = 2;
    static INIT_STARTED: number = 3;
    static INIT_COMPLETE: number = 4;
    static FETCH_STARTED: number = 5;
    static FETCH_COMPLETE: number = 6;
    static  SYNC_STARTED:number = 7;
    static SYNC_COMPLETE: number = 8;
}


export class ItemSyncState {
    static NEW: number = 1;
    static CHANGE: number = 2;
    static DELETE: number = 4;
}

export class OpCodes {
    static CREATE: number = 0;
    static UPDATE: number = 1;
    static DELETE: number = 2;
    static MAX_OP: number = 3;
}
